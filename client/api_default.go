/*
 * Rekki.com Supply API
 *
 * The base URL for all API endpoints is https://api.rekki.com  Api key value contains of word Bearer together with api key that you can get from integrations@rekki.com 
 *
 * API version: 
 * Contact: integrations@rekki.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// DefaultApiService DefaultApi service
type DefaultApiService service

/*
ConfirmOrders Confirm a pending order by its reference code.
Notifies the buyer that the order has been acknowledged.  Status:&#x60; 200 OK&#x60; Body: &#x60;{ success: true}&#x60;  Status: &#x60;400 Conflict&#x60; Body: &#x60;{\&quot;error\&quot;:\&quot;Order already confirmed\&quot;,\&quot;order_id\&quot;:...}&#x60;  Status: &#x60;400 Not Found&#x60; Body: &#x60;{\&quot;error\&quot;:\&quot;Order not found\&quot;,\&quot;order_id\&quot;:...}&#x60;  in errors order_id denotes the order that failed to be confirmed  **the processing stops at first error** 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return MainSetIntegrateOrdersInput
*/
func (a *DefaultApiService) ConfirmOrders(ctx _context.Context, xREKKIAuthorizationType string, input MainSetIntegrateOrdersInput) (MainSetIntegrateOrdersInput, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainSetIntegrateOrdersInput
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/orders/confirm"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainFailedOrderError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ConfirmOrdersV3 Confirm a pending order by its reference code.
Notifies the buyer that the order has been acknowledged.  Status:&#x60; 200 OK&#x60; Body: &#x60;{ success: true}&#x60;  Status: &#x60;400 Conflict&#x60; Body: &#x60;{\&quot;error\&quot;:\&quot;Order already confirmed\&quot;,\&quot;order_id\&quot;:...}&#x60;  Status: &#x60;400 Not Found&#x60; Body: &#x60;{\&quot;error\&quot;:\&quot;Order not found\&quot;,\&quot;order_id\&quot;:...}&#x60;  in errors order_id denotes the order that failed to be confirmed  **the processing stops at first error** 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return V3ConfirmOrdersInput
*/
func (a *DefaultApiService) ConfirmOrdersV3(ctx _context.Context, xREKKIAuthorizationType string, input V3ConfirmOrdersInput) (V3ConfirmOrdersInput, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3ConfirmOrdersInput
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/orders/confirm"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3FailedOrderError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
DeleteCatalogItem Delete an item from catalog
Delete an item from your catalog by its unique ID.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param id ID of the item to retrieve. Item IDs are discoverable when listing items.
@return MainSuccessConfirmation
*/
func (a *DefaultApiService) DeleteCatalogItem(ctx _context.Context, xREKKIAuthorizationType string, id string) (MainSuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainSuccessConfirmation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/catalog/items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
DeleteCatalogItemsV3 Delete items from catalog
Delete items from the catalog by its unique IDs.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return V3SuccessConfirmation
*/
func (a *DefaultApiService) DeleteCatalogItemsV3(ctx _context.Context, xREKKIAuthorizationType string, input V3DeleteCatalogItemsInput) (V3SuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3SuccessConfirmation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/catalog/items/delete"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetCatalogItem Lists all orders placed for the supplier that were placed through REKKI.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param id ID of the item to retrieve. Item IDs are discoverable when listing items.
@return MainApiSupplierCatalogItem
*/
func (a *DefaultApiService) GetCatalogItem(ctx _context.Context, xREKKIAuthorizationType string, id string) (MainApiSupplierCatalogItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainApiSupplierCatalogItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/catalog/items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetCatalogItemV3 Fetch a specific catalog item by its Id.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param id ID of the item to retrieve. Item IDs are discoverable when listing items.
@return V3ApiSupplierCatalogItem
*/
func (a *DefaultApiService) GetCatalogItemV3(ctx _context.Context, xREKKIAuthorizationType string, id string) (V3ApiSupplierCatalogItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3ApiSupplierCatalogItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/catalog/items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V3GenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetCatalogItems Get catalog items for authenticated supplier
Lists all your catalog items. Sorted by creation date, with the oldest appearing first. No input parameters. Options for pagination and sorting direction may be introduced later. Response is a JSON object with a data property that contains catalog items of the authenticated supplier.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
@return MainCatalogItems
*/
func (a *DefaultApiService) GetCatalogItems(ctx _context.Context, xREKKIAuthorizationType string) (MainCatalogItems, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainCatalogItems
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/catalog/items"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetCatalogItemsV3 Get catalog items for authenticated supplier
Lists all your catalog items. Sorted by creation date, with the oldest appearing first. No input parameters. Options for pagination and sorting direction may be introduced later. Response is a JSON object with a data property that contains catalog items of the authenticated supplier.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
@return V3CatalogItems
*/
func (a *DefaultApiService) GetCatalogItemsV3(ctx _context.Context, xREKKIAuthorizationType string) (V3CatalogItems, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3CatalogItems
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/catalog/items"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ListNotIntegratedOrders Lists all orders placed for the supplier that were placed through REKKI and not marked as integrated.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return MainOrderListOutput
*/
func (a *DefaultApiService) ListNotIntegratedOrders(ctx _context.Context, xREKKIAuthorizationType string, input MainOrderListInput) (MainOrderListOutput, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainOrderListOutput
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/orders/list_not_integrated"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ListOrdersBySupplier Lists all orders placed for the supplier that were placed through REKKI.
Orders are limited to max 30 days old (i.e. timestamp must be within 30 days).  We recommend polling for orders by setting the new request timestamp to the time of the last successful request.  After you start using the API, you should request orders since last received order&#39;s inserted_at_ts, since the API returns orders created &gt;&#x3D; of the requested timestamp, you will always get at order from which you took the timestamp in the response. This will be explained again in the provided example.  Keep in mind that since you can have more than one order per since, you must not do since: last_order.inserted_at_ts + 1, but keep the last order you received&#39;s reference and ignore the duplicate.  After you start using the API, you should request orders since last received order&#39;s inserted_at_ts, since the API returns orders created &gt;&#x3D; of the requested timestamp, you will **always** get at order from which you took the timestamp in the response. This will be explained again in the provided example.  Keep in mind that since you can have more than one order per since, you must not do since: last_order.inserted_at_ts + 1, but keep the last order you received&#39;s reference and ignore the duplicate.  ## Exaple usage  In this JavaScript example, all orders are retrieved. Then it keeps pulling for new orders since the last order, every hour.    &#x60;&#x60;&#x60;   const fetch &#x3D; require(\&quot;node-fetch\&quot;);    const sleep &#x3D; function sleep(ms) {     return new Promise(resolve &#x3D;&gt; setTimeout(resolve, ms));   };    const fetch_orders &#x3D; async function(token, since) {     let r &#x3D; await fetch(       \&quot;https://api.rekki.com/api/catalog/integration/list_orders_by_supplier\&quot;,       {         method: \&quot;POST\&quot;,         headers: {           Authorization: \&quot;Bearer \&quot; + token,           \&quot;X-REKKI-Authorization-Type\&quot;: \&quot;supplier_api_token\&quot;,           \&quot;Content-Type\&quot;: \&quot;application/json\&quot;,           Accept: \&quot;application/json\&quot;         },         body: JSON.stringify({ since })       }     );     return await r.json();   };    const poll &#x3D; async function(token, last_rekki_order_time) {     let last_order_reference &#x3D; undefined;      while (true) {       console.log(\&quot;requesting orders since \&quot; + last_rekki_order_time);       let response &#x3D; await fetch_orders(token, last_rekki_order_time);        for (let order of response.orders) {         if (order.reference &#x3D;&#x3D; last_order_reference) {           // here is where we are ignoring the order we           // took the inserted_at_ts from           // but since we can have more orders in the same inserted_at_ts           // you can&#39;t just do since: inserted_at_ts+1           continue;         }         if (order.inserted_at_ts &gt;&#x3D; last_rekki_order_time) {           last_rekki_order_time &#x3D; order.inserted_at_ts;           last_order_reference &#x3D; order.reference;         }          // process(order)         console.log(order);       }       await sleep(3600 * 1000); // wait 1 hour     }   };    poll(\&quot;XXXXXXX-XXXX-XXXX-XXXXX-XXXXXXXXXXXX\&quot;, parseInt((+new Date() /1000) - 3600 * 24 * 30));   &#x60;&#x60;&#x60; 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return MainOrderListOutput
*/
func (a *DefaultApiService) ListOrdersBySupplier(ctx _context.Context, xREKKIAuthorizationType string, input MainOrderListInput) (MainOrderListOutput, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainOrderListOutput
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/orders/list"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ListOrdersBySupplierV3 Lists all orders placed for the supplier that were placed through REKKI.
**UPDATE TO REFLECT V3 CHANGES**  Orders are limited to max 30 days old (i.e. timestamp must be within 30 days).  We recommend polling for orders by setting the new request timestamp to the time of the last successful request.  After you start using the API, you should request orders since last received order&#39;s inserted_at_ts, since the API returns orders created &gt;&#x3D; of the requested timestamp, you will always get at order from which you took the timestamp in the response. This will be explained again in the provided example.  Keep in mind that since you can have more than one order per since, you must not do since: last_order.inserted_at_ts + 1, but keep the last order you received&#39;s reference and ignore the duplicate.  After you start using the API, you should request orders since last received order&#39;s inserted_at_ts, since the API returns orders created &gt;&#x3D; of the requested timestamp, you will **always** get at order from which you took the timestamp in the response. This will be explained again in the provided example.  Keep in mind that since you can have more than one order per since, you must not do since: last_order.inserted_at_ts + 1, but keep the last order you received&#39;s reference and ignore the duplicate.  ## Exaple usage  In this JavaScript example, all orders are retrieved. Then it keeps pulling for new orders since the last order, every hour.    &#x60;&#x60;&#x60;   const fetch &#x3D; require(\&quot;node-fetch\&quot;);    const sleep &#x3D; function sleep(ms) {     return new Promise(resolve &#x3D;&gt; setTimeout(resolve, ms));   };    const fetch_orders &#x3D; async function(token, since) {     let r &#x3D; await fetch(       \&quot;https://api.rekki.com/api/catalog/integration/list_orders_by_supplier\&quot;,       {         method: \&quot;POST\&quot;,         headers: {           Authorization: \&quot;Bearer \&quot; + token,           \&quot;X-REKKI-Authorization-Type\&quot;: \&quot;supplier_api_token\&quot;,           \&quot;Content-Type\&quot;: \&quot;application/json\&quot;,           Accept: \&quot;application/json\&quot;         },         body: JSON.stringify({ since })       }     );     return await r.json();   };    const poll &#x3D; async function(token, last_rekki_order_time) {     let last_order_reference &#x3D; undefined;      while (true) {       console.log(\&quot;requesting orders since \&quot; + last_rekki_order_time);       let response &#x3D; await fetch_orders(token, last_rekki_order_time.toISOString());        for (let order of response.orders) {         if (order.reference &#x3D;&#x3D; last_order_reference) {           // here is where we are ignoring the order we           // took the inserted_at from           // but since we can have more orders in the same inserted_at           // you can&#39;t just do since: inserted_at + 1 second           continue;         }         if (+new Date(order.inserted_at) &gt;&#x3D; +last_rekki_order_time) {           last_rekki_order_time &#x3D; order.inserted_at;           last_order_reference &#x3D; order.reference;         }          // process(order)         console.log(order);       }       await sleep(3600 * 1000); // wait 1 hour     }   };    let startDate &#x3D; new Date()   startDate.setDate(startDate.getDate() - 30)   poll(\&quot;XXXXXXX-XXXX-XXXX-XXXXX-XXXXXXXXXXXX\&quot;, startDate)   &#x60;&#x60;&#x60; 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return V3OrderListOutput
*/
func (a *DefaultApiService) ListOrdersBySupplierV3(ctx _context.Context, xREKKIAuthorizationType string, input V3OrderListInput) (V3OrderListOutput, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3OrderListOutput
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/orders/list"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3GenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
MarkIntegrationError Report failure to integrate an order
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return MainSuccessConfirmation
*/
func (a *DefaultApiService) MarkIntegrationError(ctx _context.Context, xREKKIAuthorizationType string, input MainSetErrorOrderInput) (MainSuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainSuccessConfirmation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/orders/set_error"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainFailedOrderError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
MarkIntegrationErrorV3 Report failure to integrate an order
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return V3SuccessConfirmation
*/
func (a *DefaultApiService) MarkIntegrationErrorV3(ctx _context.Context, xREKKIAuthorizationType string, input V3SetErrorOrderInput) (V3SuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3SuccessConfirmation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/orders/set_error"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3FailedOrderError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
MarkOrdersIntegrated Mark orders as integrated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return MainUpdateSuccess
*/
func (a *DefaultApiService) MarkOrdersIntegrated(ctx _context.Context, xREKKIAuthorizationType string, input MainSetIntegrateOrdersInput) (MainUpdateSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainUpdateSuccess
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/orders/set_integrated"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
MarkOrdersIntegratedV3 Mark orders as integrated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return V3UpdateSuccess
*/
func (a *DefaultApiService) MarkOrdersIntegratedV3(ctx _context.Context, xREKKIAuthorizationType string, input V3SetIntegratedOrdersInput) (V3UpdateSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3UpdateSuccess
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/orders/set_integrated"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3GenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
PostLogMessage Post a log message for the supplier for internal debugging. There is no need to handle response from this endpoint
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return string
*/
func (a *DefaultApiService) PostLogMessage(ctx _context.Context, xREKKIAuthorizationType string, input MainLogMessage) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/log"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
PostLogMessageV3 Post a log message for the supplier for internal debugging. There is no need to handle response from this endpoint
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return string
*/
func (a *DefaultApiService) PostLogMessageV3(ctx _context.Context, xREKKIAuthorizationType string, input V3LogMessage) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/log"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ReplaceCatalog Drop all existing items from the catalog and upload new ones
### Parameters  - **&#x60;id&#x60;** REKKI&#39;s ID to uniquely identify the catalog item (for REKKI internal reference). If &#x60;id&#x60; is specified the item will be update, if not it will attempt to insert it. - **&#x60;product_code&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Product code for the item that maps to the supplier&#39;s catalog. Suppliers can modify the product code for future orders at https://supplier.rekki.com - **&#x60;name&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Item name as would be defined on the customer&#39;s product list. - **&#x60;currency&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is GBP&lt;/span&gt; Currency code for the price. In [ISO 4217][] three-letter format. - **&#x60;units_prices&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; List of units and their prices that the item can be ordered in. - **&#x60;units_prices.unit&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; A unit that the item can be ordered in. - **&#x60;units_prices.price_cents&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is 0&lt;/span&gt; The order price in cents for the item per unit. For example, a currency of GBP with unit 5L and price 850 means a 5L item can be ordered for 8.50. - **&#x60;units_prices.stock_count&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; The number of items in stock for the related unit. - **&#x60;availability&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is \&quot;in_stock\&quot;&lt;/span&gt; Availability status of the item. Can be \&quot;in_stock\&quot;, \&quot;out_of_stock\&quot;, or \&quot;discontinued\&quot;. - **&#x60;description&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Short description of the item. - **&#x60;allergens&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of allergens for the item, if any. - **&#x60;allergens.type&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when allergens is given&lt;/span&gt; Type of allergy. For example \&quot;contains peanuts\&quot; or \&quot;may contain peanuts\&quot;. - **&#x60;allergens.symptoms&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of symptoms for the allergy. - **&#x60;order_cutoff_times&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Cutt-off times are the minimum amount of time before delivery when the item can still be ordered. - **&#x60;order_cutoff_times.{mon,tue,wed,thu,fri,sat,sun}&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Minimum amount of time, in hours, that an item needs to be ordered in advance of delivery for the given day. - **&#x60;replacement_products&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of product codes for alternative items when this item is not available. - **&#x60;seasonality&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of date ranges when the item is in-season. - **&#x60;seasonality.start_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;   The start date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;.   - **&#x60;seasonality.end_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;     The end date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return MainSuccessConfirmation
*/
func (a *DefaultApiService) ReplaceCatalog(ctx _context.Context, xREKKIAuthorizationType string, input MainReplaceCatalogInput) (MainSuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainSuccessConfirmation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/catalog/replace"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ReplaceCatalogV3 Drop all existing items from the catalog and upload new ones
### Parameters  - **&#x60;id&#x60;** REKKI&#39;s ID to uniquely identify the catalog item (for REKKI internal reference). If &#x60;id&#x60; is specified the item will be update, if not it will attempt to insert it. - **&#x60;product_code&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Product code for the item that maps to the supplier&#39;s catalog. Suppliers can modify the product code for future orders at https://supplier.rekki.com - **&#x60;name&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Item name as would be defined on the customer&#39;s product list. - **&#x60;currency&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is GBP&lt;/span&gt; Currency code for the price. In [ISO 4217][] three-letter format. - **&#x60;units_prices&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; List of units and their prices that the item can be ordered in. - **&#x60;units_prices.unit&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; A unit that the item can be ordered in. - **&#x60;units_prices.price_cents&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is 0&lt;/span&gt; The order price in cents for the item per unit. For example, a currency of GBP with unit 5L and price 850 means a 5L item can be ordered for 8.50. - **&#x60;units_prices.stock_count&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; The number of items in stock for the related unit. - **&#x60;availability&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is \&quot;in_stock\&quot;&lt;/span&gt; Availability status of the item. Can be \&quot;in_stock\&quot;, \&quot;out_of_stock\&quot;, or \&quot;discontinued\&quot;. - **&#x60;description&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Short description of the item. - **&#x60;allergens&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of allergens for the item, if any. - **&#x60;allergens.type&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when allergens is given&lt;/span&gt; Type of allergy. For example \&quot;contains peanuts\&quot; or \&quot;may contain peanuts\&quot;. - **&#x60;allergens.symptoms&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of symptoms for the allergy. - **&#x60;order_cutoff_times&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Cutt-off times are the minimum amount of time before delivery when the item can still be ordered. - **&#x60;order_cutoff_times.{mon,tue,wed,thu,fri,sat,sun}&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Minimum amount of time, in hours, that an item needs to be ordered in advance of delivery for the given day. - **&#x60;replacement_products&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of product codes for alternative items when this item is not available. - **&#x60;seasonality&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of date ranges when the item is in-season. - **&#x60;seasonality.start_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;   The start date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;.   - **&#x60;seasonality.end_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;     The end date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return V3SuccessConfirmation
*/
func (a *DefaultApiService) ReplaceCatalogV3(ctx _context.Context, xREKKIAuthorizationType string, input V3ReplaceCatalogInput) (V3SuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3SuccessConfirmation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/catalog/replace"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3GenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
UpdateCatalogItem Creates or Updates an item on your catalog. If item with this product_code already exists, you can update this item. Item is looked up by product code
### Parameters  - **&#x60;id&#x60;** REKKI&#39;s ID to uniquely identify the catalog item (for REKKI internal reference). If &#x60;id&#x60; is specified the item will be update, if not it will attempt to insert it. - **&#x60;product_code&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Product code for the item that maps to the supplier&#39;s catalog. Suppliers can modify the product code for future orders at https://supplier.rekki.com - **&#x60;name&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Item name as would be defined on the customer&#39;s product list. - **&#x60;currency&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is GBP&lt;/span&gt; Currency code for the price. In [ISO 4217][] three-letter format. - **&#x60;units_prices&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; List of units and their prices that the item can be ordered in. - **&#x60;units_prices.unit&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; A unit that the item can be ordered in. - **&#x60;units_prices.price_cents&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is 0&lt;/span&gt; The order price in cents for the item per unit. For example, a currency of GBP with unit 5L and price 850 means a 5L item can be ordered for 8.50. - **&#x60;units_prices.stock_count&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; The number of items in stock for the related unit. - **&#x60;availability&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is \&quot;in_stock\&quot;&lt;/span&gt; Availability status of the item. Can be \&quot;in_stock\&quot;, \&quot;out_of_stock\&quot;, or \&quot;discontinued\&quot;. - **&#x60;description&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Short description of the item. - **&#x60;allergens&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of allergens for the item, if any. - **&#x60;allergens.type&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when allergens is given&lt;/span&gt; Type of allergy. For example \&quot;contains peanuts\&quot; or \&quot;may contain peanuts\&quot;. - **&#x60;allergens.symptoms&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of symptoms for the allergy. - **&#x60;order_cutoff_times&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Cutt-off times are the minimum amount of time before delivery when the item can still be ordered. - **&#x60;order_cutoff_times.{mon,tue,wed,thu,fri,sat,sun}&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Minimum amount of time, in hours, that an item needs to be ordered in advance of delivery for the given day. - **&#x60;replacement_products&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of product codes for alternative items when this item is not available. - **&#x60;seasonality&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of date ranges when the item is in-season. - **&#x60;seasonality.start_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;   The start date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;.   - **&#x60;seasonality.end_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;     The end date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return MainApiSupplierCatalogItem
*/
func (a *DefaultApiService) UpdateCatalogItem(ctx _context.Context, xREKKIAuthorizationType string, input MainApiSupplierCatalogItem) (MainApiSupplierCatalogItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainApiSupplierCatalogItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/catalog/items"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
UpdateCatalogItemAvailability Update availability status for one of the items in the catalog
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return MainUpdateSuccess
*/
func (a *DefaultApiService) UpdateCatalogItemAvailability(ctx _context.Context, xREKKIAuthorizationType string, input MainSetStockStatusInput) (MainUpdateSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainUpdateSuccess
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v2/catalog/items/availability"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
UpdateCatalogItemAvailabilityV3 Update availability status for one of the items in the catalog
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return V3UpdateSuccess
*/
func (a *DefaultApiService) UpdateCatalogItemAvailabilityV3(ctx _context.Context, xREKKIAuthorizationType string, input V3SetStockStatusInput) (V3UpdateSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3UpdateSuccess
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/catalog/items/availability"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3GenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
UpdateCatalogItemsV3 Creates or Updates multiple items on your catalog. If item with this product_code already exists, you can update this item. Item is looked up by product code
### Parameters  - **&#x60;id&#x60;** REKKI&#39;s ID to uniquely identify the catalog item (for REKKI internal reference). If &#x60;id&#x60; is specified the item will be update, if not it will attempt to insert it. - **&#x60;product_code&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Product code for the item that maps to the supplier&#39;s catalog. Suppliers can modify the product code for future orders at https://supplier.rekki.com - **&#x60;name&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Item name as would be defined on the customer&#39;s product list. - **&#x60;currency&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is GBP&lt;/span&gt; Currency code for the price. In [ISO 4217][] three-letter format. - **&#x60;units_prices&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; List of units and their prices that the item can be ordered in. - **&#x60;units_prices.unit&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; A unit that the item can be ordered in. - **&#x60;units_prices.price_cents&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is 0&lt;/span&gt; The order price in cents for the item per unit. For example, a currency of GBP with unit 5L and price 850 means a 5L item can be ordered for 8.50. - **&#x60;units_prices.stock_count&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; The number of items in stock for the related unit. - **&#x60;availability&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is \&quot;in_stock\&quot;&lt;/span&gt; Availability status of the item. Can be \&quot;in_stock\&quot;, \&quot;out_of_stock\&quot;, or \&quot;discontinued\&quot;. - **&#x60;description&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Short description of the item. - **&#x60;allergens&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of allergens for the item, if any. - **&#x60;allergens.type&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when allergens is given&lt;/span&gt; Type of allergy. For example \&quot;contains peanuts\&quot; or \&quot;may contain peanuts\&quot;. - **&#x60;allergens.symptoms&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of symptoms for the allergy. - **&#x60;order_cutoff_times&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Cutt-off times are the minimum amount of time before delivery when the item can still be ordered. - **&#x60;order_cutoff_times.{mon,tue,wed,thu,fri,sat,sun}&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Minimum amount of time, in hours, that an item needs to be ordered in advance of delivery for the given day. - **&#x60;replacement_products&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of product codes for alternative items when this item is not available. - **&#x60;seasonality&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of date ranges when the item is in-season. - **&#x60;seasonality.start_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;   The start date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;.   - **&#x60;seasonality.end_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;     The end date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return V3CatalogItems
*/
func (a *DefaultApiService) UpdateCatalogItemsV3(ctx _context.Context, xREKKIAuthorizationType string, input V3UpdateCatalogInput) (V3CatalogItems, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3CatalogItems
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/catalog/items"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3GenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
