/*
 * Rekki.com Supplier API
 *
 * The base URL for all API endpoints is https://api.rekki.com  Api key value contains of word Bearer together with api key that you can get from integrations@rekki.com 
 *
 * API version: 
 * Contact: integrations@rekki.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// OrdersApiService OrdersApi service
type OrdersApiService service

type ApiConfirmOrdersRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	xREKKIAuthorizationType *string
	input *MainSetIntegrateOrdersInput
}

func (r ApiConfirmOrdersRequest) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiConfirmOrdersRequest {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiConfirmOrdersRequest) Input(input MainSetIntegrateOrdersInput) ApiConfirmOrdersRequest {
	r.input = &input
	return r
}

func (r ApiConfirmOrdersRequest) Execute() (MainSetIntegrateOrdersInput, *_nethttp.Response, error) {
	return r.ApiService.ConfirmOrdersExecute(r)
}

/*
 * ConfirmOrders Confirm a pending order by its reference code.
 * Notifies the buyer that the order has been acknowledged.

Status:` 200 OK`
Body: `{ success: true}`

Status: `400 Conflict`
Body: `{"error":"Order already confirmed","order_id":...}`

Status: `400 Not Found`
Body: `{"error":"Order not found","order_id":...}`

in errors order_id denotes the order that failed to be confirmed

**the processing stops at first error**

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiConfirmOrdersRequest
 */
func (a *OrdersApiService) ConfirmOrders(ctx _context.Context) ApiConfirmOrdersRequest {
	return ApiConfirmOrdersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return MainSetIntegrateOrdersInput
 */
func (a *OrdersApiService) ConfirmOrdersExecute(r ApiConfirmOrdersRequest) (MainSetIntegrateOrdersInput, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainSetIntegrateOrdersInput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.ConfirmOrders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/orders/confirm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainFailedOrderError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConfirmOrdersV3Request struct {
	ctx _context.Context
	ApiService *OrdersApiService
	xREKKIAuthorizationType *string
	input *V3ConfirmOrdersInput
}

func (r ApiConfirmOrdersV3Request) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiConfirmOrdersV3Request {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiConfirmOrdersV3Request) Input(input V3ConfirmOrdersInput) ApiConfirmOrdersV3Request {
	r.input = &input
	return r
}

func (r ApiConfirmOrdersV3Request) Execute() (V3ConfirmOrdersInput, *_nethttp.Response, error) {
	return r.ApiService.ConfirmOrdersV3Execute(r)
}

/*
 * ConfirmOrdersV3 Confirm a pending order by its reference code.
 * Notifies the buyer that the order has been acknowledged.

Status:` 200 OK`
Body: `{ success: true}`

Status: `400 Conflict`
Body: `{"error":"Order already confirmed","order_id":...}`

Status: `400 Not Found`
Body: `{"error":"Order not found","order_id":...}`

in errors order_id denotes the order that failed to be confirmed

**the processing stops at first error**

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiConfirmOrdersV3Request
 */
func (a *OrdersApiService) ConfirmOrdersV3(ctx _context.Context) ApiConfirmOrdersV3Request {
	return ApiConfirmOrdersV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return V3ConfirmOrdersInput
 */
func (a *OrdersApiService) ConfirmOrdersV3Execute(r ApiConfirmOrdersV3Request) (V3ConfirmOrdersInput, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3ConfirmOrdersInput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.ConfirmOrdersV3")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v3/orders/confirm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3FailedOrderError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListNotIntegratedOrdersRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	xREKKIAuthorizationType *string
	input *MainOrderListInput
}

func (r ApiListNotIntegratedOrdersRequest) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiListNotIntegratedOrdersRequest {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiListNotIntegratedOrdersRequest) Input(input MainOrderListInput) ApiListNotIntegratedOrdersRequest {
	r.input = &input
	return r
}

func (r ApiListNotIntegratedOrdersRequest) Execute() (MainOrderListOutput, *_nethttp.Response, error) {
	return r.ApiService.ListNotIntegratedOrdersExecute(r)
}

/*
 * ListNotIntegratedOrders Lists all orders placed for the supplier that were placed through REKKI and not marked as integrated.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListNotIntegratedOrdersRequest
 */
func (a *OrdersApiService) ListNotIntegratedOrders(ctx _context.Context) ApiListNotIntegratedOrdersRequest {
	return ApiListNotIntegratedOrdersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return MainOrderListOutput
 */
func (a *OrdersApiService) ListNotIntegratedOrdersExecute(r ApiListNotIntegratedOrdersRequest) (MainOrderListOutput, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainOrderListOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.ListNotIntegratedOrders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/orders/list_not_integrated"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOrdersBySupplierRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	xREKKIAuthorizationType *string
	input *MainOrderListInput
}

func (r ApiListOrdersBySupplierRequest) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiListOrdersBySupplierRequest {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiListOrdersBySupplierRequest) Input(input MainOrderListInput) ApiListOrdersBySupplierRequest {
	r.input = &input
	return r
}

func (r ApiListOrdersBySupplierRequest) Execute() (MainOrderListOutput, *_nethttp.Response, error) {
	return r.ApiService.ListOrdersBySupplierExecute(r)
}

/*
 * ListOrdersBySupplier Lists all orders placed for the supplier that were placed through REKKI.
 * Orders are limited to max 30 days old (i.e. timestamp must be within 30 days).

We recommend polling for orders by setting the new request timestamp to the time of the last successful request.

After you start using the API, you should request orders since last received order's inserted_at_ts, since the API returns orders created >= of the requested timestamp, you will always get at order from which you took the timestamp in the response. This will be explained again in the provided example.

Keep in mind that since you can have more than one order per since, you must not do since: last_order.inserted_at_ts + 1, but keep the last order you received's reference and ignore the duplicate.

After you start using the API, you should request orders since last received order's inserted_at_ts, since the API returns orders created >= of the requested timestamp, you will **always** get at order from which you took the timestamp in the response. This will be explained again in the provided example.

Keep in mind that since you can have more than one order per since, you must not do since: last_order.inserted_at_ts + 1, but keep the last order you received's reference and ignore the duplicate.

## Exaple usage

In this JavaScript example, all orders are retrieved. Then it keeps pulling for new orders since the last order, every hour.

  ```
  const fetch = require("node-fetch");

  const sleep = function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  };

  const fetch_orders = async function(token, since) {
    let r = await fetch(
      "https://api.rekki.com/api/catalog/integration/list_orders_by_supplier",
      {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "X-REKKI-Authorization-Type": "supplier_api_token",
          "Content-Type": "application/json",
          Accept: "application/json"
        },
        body: JSON.stringify({ since })
      }
    );
    return await r.json();
  };

  const poll = async function(token, last_rekki_order_time) {
    let last_order_reference = undefined;

    while (true) {
      console.log("requesting orders since " + last_rekki_order_time);
      let response = await fetch_orders(token, last_rekki_order_time);

      for (let order of response.orders) {
        if (order.reference == last_order_reference) {
          // here is where we are ignoring the order we
          // took the inserted_at_ts from
          // but since we can have more orders in the same inserted_at_ts
          // you can't just do since: inserted_at_ts+1
          continue;
        }
        if (order.inserted_at_ts >= last_rekki_order_time) {
          last_rekki_order_time = order.inserted_at_ts;
          last_order_reference = order.reference;
        }

        // process(order)
        console.log(order);
      }
      await sleep(3600 * 1000); // wait 1 hour
    }
  };

  poll("XXXXXXX-XXXX-XXXX-XXXXX-XXXXXXXXXXXX", parseInt((+new Date() /1000) - 3600 * 24 * 30));
  ```

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListOrdersBySupplierRequest
 */
func (a *OrdersApiService) ListOrdersBySupplier(ctx _context.Context) ApiListOrdersBySupplierRequest {
	return ApiListOrdersBySupplierRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return MainOrderListOutput
 */
func (a *OrdersApiService) ListOrdersBySupplierExecute(r ApiListOrdersBySupplierRequest) (MainOrderListOutput, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainOrderListOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.ListOrdersBySupplier")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/orders/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOrdersBySupplierV3Request struct {
	ctx _context.Context
	ApiService *OrdersApiService
	xREKKIAuthorizationType *string
	input *V3OrderListInput
}

func (r ApiListOrdersBySupplierV3Request) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiListOrdersBySupplierV3Request {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiListOrdersBySupplierV3Request) Input(input V3OrderListInput) ApiListOrdersBySupplierV3Request {
	r.input = &input
	return r
}

func (r ApiListOrdersBySupplierV3Request) Execute() (V3OrderListOutput, *_nethttp.Response, error) {
	return r.ApiService.ListOrdersBySupplierV3Execute(r)
}

/*
 * ListOrdersBySupplierV3 Lists all orders placed for the supplier that were placed through REKKI.
 * **UPDATE TO REFLECT V3 CHANGES**

Orders are limited to max 30 days old (i.e. timestamp must be within 30 days).

We recommend polling for orders by setting the new request timestamp to the time of the last successful request.

After you start using the API, you should request orders since last received order's inserted_at_ts, since the API returns orders created >= of the requested timestamp, you will always get at order from which you took the timestamp in the response. This will be explained again in the provided example.

Keep in mind that since you can have more than one order per since, you must not do since: last_order.inserted_at_ts + 1, but keep the last order you received's reference and ignore the duplicate.

After you start using the API, you should request orders since last received order's inserted_at_ts, since the API returns orders created >= of the requested timestamp, you will **always** get at order from which you took the timestamp in the response. This will be explained again in the provided example.

Keep in mind that since you can have more than one order per since, you must not do since: last_order.inserted_at_ts + 1, but keep the last order you received's reference and ignore the duplicate.

## Exaple usage

In this JavaScript example, all orders are retrieved. Then it keeps pulling for new orders since the last order, every hour.

  ```
  const fetch = require("node-fetch");

  const sleep = function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  };

  const fetch_orders = async function(token, since) {
    let r = await fetch(
      "https://api.rekki.com/api/catalog/integration/list_orders_by_supplier",
      {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "X-REKKI-Authorization-Type": "supplier_api_token",
          "Content-Type": "application/json",
          Accept: "application/json"
        },
        body: JSON.stringify({ since })
      }
    );
    return await r.json();
  };

  const poll = async function(token, last_rekki_order_time) {
    let last_order_reference = undefined;

    while (true) {
      console.log("requesting orders since " + last_rekki_order_time);
      let response = await fetch_orders(token, last_rekki_order_time.toISOString());

      for (let order of response.orders) {
        if (order.reference == last_order_reference) {
          // here is where we are ignoring the order we
          // took the inserted_at from
          // but since we can have more orders in the same inserted_at
          // you can't just do since: inserted_at + 1 second
          continue;
        }
        if (+new Date(order.inserted_at) >= +last_rekki_order_time) {
          last_rekki_order_time = order.inserted_at;
          last_order_reference = order.reference;
        }

        // process(order)
        console.log(order);
      }
      await sleep(3600 * 1000); // wait 1 hour
    }
  };

  let startDate = new Date()
  startDate.setDate(startDate.getDate() - 30)
  poll("XXXXXXX-XXXX-XXXX-XXXXX-XXXXXXXXXXXX", startDate)
  ```

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListOrdersBySupplierV3Request
 */
func (a *OrdersApiService) ListOrdersBySupplierV3(ctx _context.Context) ApiListOrdersBySupplierV3Request {
	return ApiListOrdersBySupplierV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return V3OrderListOutput
 */
func (a *OrdersApiService) ListOrdersBySupplierV3Execute(r ApiListOrdersBySupplierV3Request) (V3OrderListOutput, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3OrderListOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.ListOrdersBySupplierV3")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v3/orders/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3GenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarkIntegrationErrorRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	xREKKIAuthorizationType *string
	input *MainSetErrorOrderInput
}

func (r ApiMarkIntegrationErrorRequest) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiMarkIntegrationErrorRequest {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiMarkIntegrationErrorRequest) Input(input MainSetErrorOrderInput) ApiMarkIntegrationErrorRequest {
	r.input = &input
	return r
}

func (r ApiMarkIntegrationErrorRequest) Execute() (MainSuccessConfirmation, *_nethttp.Response, error) {
	return r.ApiService.MarkIntegrationErrorExecute(r)
}

/*
 * MarkIntegrationError Report failure to integrate an order
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiMarkIntegrationErrorRequest
 */
func (a *OrdersApiService) MarkIntegrationError(ctx _context.Context) ApiMarkIntegrationErrorRequest {
	return ApiMarkIntegrationErrorRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return MainSuccessConfirmation
 */
func (a *OrdersApiService) MarkIntegrationErrorExecute(r ApiMarkIntegrationErrorRequest) (MainSuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainSuccessConfirmation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.MarkIntegrationError")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/orders/set_error"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainFailedOrderError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarkIntegrationErrorV3Request struct {
	ctx _context.Context
	ApiService *OrdersApiService
	xREKKIAuthorizationType *string
	input *V3SetErrorOrderInput
}

func (r ApiMarkIntegrationErrorV3Request) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiMarkIntegrationErrorV3Request {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiMarkIntegrationErrorV3Request) Input(input V3SetErrorOrderInput) ApiMarkIntegrationErrorV3Request {
	r.input = &input
	return r
}

func (r ApiMarkIntegrationErrorV3Request) Execute() (V3SuccessConfirmation, *_nethttp.Response, error) {
	return r.ApiService.MarkIntegrationErrorV3Execute(r)
}

/*
 * MarkIntegrationErrorV3 Report failure to integrate an order
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiMarkIntegrationErrorV3Request
 */
func (a *OrdersApiService) MarkIntegrationErrorV3(ctx _context.Context) ApiMarkIntegrationErrorV3Request {
	return ApiMarkIntegrationErrorV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return V3SuccessConfirmation
 */
func (a *OrdersApiService) MarkIntegrationErrorV3Execute(r ApiMarkIntegrationErrorV3Request) (V3SuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3SuccessConfirmation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.MarkIntegrationErrorV3")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v3/orders/set_error"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3FailedOrderError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarkOrdersIntegratedRequest struct {
	ctx _context.Context
	ApiService *OrdersApiService
	xREKKIAuthorizationType *string
	input *MainSetIntegrateOrdersInput
}

func (r ApiMarkOrdersIntegratedRequest) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiMarkOrdersIntegratedRequest {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiMarkOrdersIntegratedRequest) Input(input MainSetIntegrateOrdersInput) ApiMarkOrdersIntegratedRequest {
	r.input = &input
	return r
}

func (r ApiMarkOrdersIntegratedRequest) Execute() (MainUpdateSuccess, *_nethttp.Response, error) {
	return r.ApiService.MarkOrdersIntegratedExecute(r)
}

/*
 * MarkOrdersIntegrated Mark orders as integrated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiMarkOrdersIntegratedRequest
 */
func (a *OrdersApiService) MarkOrdersIntegrated(ctx _context.Context) ApiMarkOrdersIntegratedRequest {
	return ApiMarkOrdersIntegratedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return MainUpdateSuccess
 */
func (a *OrdersApiService) MarkOrdersIntegratedExecute(r ApiMarkOrdersIntegratedRequest) (MainUpdateSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainUpdateSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.MarkOrdersIntegrated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/orders/set_integrated"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarkOrdersIntegratedV3Request struct {
	ctx _context.Context
	ApiService *OrdersApiService
	xREKKIAuthorizationType *string
	input *V3SetIntegratedOrdersInput
}

func (r ApiMarkOrdersIntegratedV3Request) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiMarkOrdersIntegratedV3Request {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiMarkOrdersIntegratedV3Request) Input(input V3SetIntegratedOrdersInput) ApiMarkOrdersIntegratedV3Request {
	r.input = &input
	return r
}

func (r ApiMarkOrdersIntegratedV3Request) Execute() (V3UpdateSuccess, *_nethttp.Response, error) {
	return r.ApiService.MarkOrdersIntegratedV3Execute(r)
}

/*
 * MarkOrdersIntegratedV3 Mark orders as integrated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiMarkOrdersIntegratedV3Request
 */
func (a *OrdersApiService) MarkOrdersIntegratedV3(ctx _context.Context) ApiMarkOrdersIntegratedV3Request {
	return ApiMarkOrdersIntegratedV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return V3UpdateSuccess
 */
func (a *OrdersApiService) MarkOrdersIntegratedV3Execute(r ApiMarkOrdersIntegratedV3Request) (V3UpdateSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3UpdateSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersApiService.MarkOrdersIntegratedV3")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v3/orders/set_integrated"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3GenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
