/*
 * Rekki.com Supplier API
 *
 * The base URL for all API endpoints is https://api.rekki.com  Api key value contains of word Bearer together with api key that you can get from integrations@rekki.com 
 *
 * API version: 
 * Contact: integrations@rekki.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// CatalogApiService CatalogApi service
type CatalogApiService service

type ApiDeleteCatalogItemRequest struct {
	ctx _context.Context
	ApiService *CatalogApiService
	xREKKIAuthorizationType *string
	id string
}

func (r ApiDeleteCatalogItemRequest) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiDeleteCatalogItemRequest {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}

func (r ApiDeleteCatalogItemRequest) Execute() (MainSuccessConfirmation, *_nethttp.Response, error) {
	return r.ApiService.DeleteCatalogItemExecute(r)
}

/*
 * DeleteCatalogItem Delete an item from catalog
 * Delete an item from your catalog by its unique ID.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id ID of the item to retrieve. Item IDs are discoverable when listing items.
 * @return ApiDeleteCatalogItemRequest
 */
func (a *CatalogApiService) DeleteCatalogItem(ctx _context.Context, id string) ApiDeleteCatalogItemRequest {
	return ApiDeleteCatalogItemRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return MainSuccessConfirmation
 */
func (a *CatalogApiService) DeleteCatalogItemExecute(r ApiDeleteCatalogItemRequest) (MainSuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainSuccessConfirmation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogApiService.DeleteCatalogItem")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/catalog/items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCatalogItemsV3Request struct {
	ctx _context.Context
	ApiService *CatalogApiService
	xREKKIAuthorizationType *string
	input *V3DeleteCatalogItemsInput
}

func (r ApiDeleteCatalogItemsV3Request) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiDeleteCatalogItemsV3Request {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiDeleteCatalogItemsV3Request) Input(input V3DeleteCatalogItemsInput) ApiDeleteCatalogItemsV3Request {
	r.input = &input
	return r
}

func (r ApiDeleteCatalogItemsV3Request) Execute() (V3SuccessConfirmation, *_nethttp.Response, error) {
	return r.ApiService.DeleteCatalogItemsV3Execute(r)
}

/*
 * DeleteCatalogItemsV3 Delete items from catalog
 * Delete items from the catalog by its unique IDs.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDeleteCatalogItemsV3Request
 */
func (a *CatalogApiService) DeleteCatalogItemsV3(ctx _context.Context) ApiDeleteCatalogItemsV3Request {
	return ApiDeleteCatalogItemsV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return V3SuccessConfirmation
 */
func (a *CatalogApiService) DeleteCatalogItemsV3Execute(r ApiDeleteCatalogItemsV3Request) (V3SuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3SuccessConfirmation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogApiService.DeleteCatalogItemsV3")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v3/catalog/items/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatalogItemRequest struct {
	ctx _context.Context
	ApiService *CatalogApiService
	xREKKIAuthorizationType *string
	id string
}

func (r ApiGetCatalogItemRequest) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiGetCatalogItemRequest {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}

func (r ApiGetCatalogItemRequest) Execute() (MainAPISupplierCatalogItem, *_nethttp.Response, error) {
	return r.ApiService.GetCatalogItemExecute(r)
}

/*
 * GetCatalogItem Lists all orders placed for the supplier that were placed through REKKI.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id ID of the item to retrieve. Item IDs are discoverable when listing items.
 * @return ApiGetCatalogItemRequest
 */
func (a *CatalogApiService) GetCatalogItem(ctx _context.Context, id string) ApiGetCatalogItemRequest {
	return ApiGetCatalogItemRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return MainAPISupplierCatalogItem
 */
func (a *CatalogApiService) GetCatalogItemExecute(r ApiGetCatalogItemRequest) (MainAPISupplierCatalogItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainAPISupplierCatalogItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogApiService.GetCatalogItem")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/catalog/items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatalogItemV3Request struct {
	ctx _context.Context
	ApiService *CatalogApiService
	xREKKIAuthorizationType *string
	id string
}

func (r ApiGetCatalogItemV3Request) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiGetCatalogItemV3Request {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}

func (r ApiGetCatalogItemV3Request) Execute() (V3APISupplierCatalogItem, *_nethttp.Response, error) {
	return r.ApiService.GetCatalogItemV3Execute(r)
}

/*
 * GetCatalogItemV3 Fetch a specific catalog item by its Id.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id ID of the item to retrieve. Item IDs are discoverable when listing items.
 * @return ApiGetCatalogItemV3Request
 */
func (a *CatalogApiService) GetCatalogItemV3(ctx _context.Context, id string) ApiGetCatalogItemV3Request {
	return ApiGetCatalogItemV3Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return V3APISupplierCatalogItem
 */
func (a *CatalogApiService) GetCatalogItemV3Execute(r ApiGetCatalogItemV3Request) (V3APISupplierCatalogItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3APISupplierCatalogItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogApiService.GetCatalogItemV3")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v3/catalog/items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V3GenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatalogItemsRequest struct {
	ctx _context.Context
	ApiService *CatalogApiService
	xREKKIAuthorizationType *string
}

func (r ApiGetCatalogItemsRequest) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiGetCatalogItemsRequest {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}

func (r ApiGetCatalogItemsRequest) Execute() (MainCatalogItems, *_nethttp.Response, error) {
	return r.ApiService.GetCatalogItemsExecute(r)
}

/*
 * GetCatalogItems Get catalog items for authenticated supplier
 * Lists all your catalog items. Sorted by creation date, with the oldest appearing first.
No input parameters. Options for pagination and sorting direction may be introduced later.
Response is a JSON object with a data property that contains catalog items of the authenticated supplier.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetCatalogItemsRequest
 */
func (a *CatalogApiService) GetCatalogItems(ctx _context.Context) ApiGetCatalogItemsRequest {
	return ApiGetCatalogItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return MainCatalogItems
 */
func (a *CatalogApiService) GetCatalogItemsExecute(r ApiGetCatalogItemsRequest) (MainCatalogItems, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainCatalogItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogApiService.GetCatalogItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/catalog/items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatalogItemsV3Request struct {
	ctx _context.Context
	ApiService *CatalogApiService
	xREKKIAuthorizationType *string
}

func (r ApiGetCatalogItemsV3Request) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiGetCatalogItemsV3Request {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}

func (r ApiGetCatalogItemsV3Request) Execute() (V3CatalogItems, *_nethttp.Response, error) {
	return r.ApiService.GetCatalogItemsV3Execute(r)
}

/*
 * GetCatalogItemsV3 Get catalog items for authenticated supplier
 * Lists all your catalog items. Sorted by creation date, with the oldest appearing first.
No input parameters. Options for pagination and sorting direction may be introduced later.
Response is a JSON object with a data property that contains catalog items of the authenticated supplier.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetCatalogItemsV3Request
 */
func (a *CatalogApiService) GetCatalogItemsV3(ctx _context.Context) ApiGetCatalogItemsV3Request {
	return ApiGetCatalogItemsV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return V3CatalogItems
 */
func (a *CatalogApiService) GetCatalogItemsV3Execute(r ApiGetCatalogItemsV3Request) (V3CatalogItems, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3CatalogItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogApiService.GetCatalogItemsV3")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v3/catalog/items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCatalogRequest struct {
	ctx _context.Context
	ApiService *CatalogApiService
	xREKKIAuthorizationType *string
	input *MainReplaceCatalogInput
}

func (r ApiReplaceCatalogRequest) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiReplaceCatalogRequest {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiReplaceCatalogRequest) Input(input MainReplaceCatalogInput) ApiReplaceCatalogRequest {
	r.input = &input
	return r
}

func (r ApiReplaceCatalogRequest) Execute() (MainSuccessConfirmation, *_nethttp.Response, error) {
	return r.ApiService.ReplaceCatalogExecute(r)
}

/*
 * ReplaceCatalog Drop all existing items from the catalog and upload new ones
 * ### Parameters

- **`id`**
REKKI's ID to uniquely identify the catalog item (for REKKI internal reference).
If `id` is specified the item will be update, if not it will attempt to insert it.
- **`product_code`**  <span style="font-size: 12px; font-weight: 500;">required</span>
Product code for the item that maps to the supplier's catalog.
Suppliers can modify the product code for future orders at https://supplier.rekki.com
- **`name`**  <span style="font-size: 12px; font-weight: 500;">required</span>
Item name as would be defined on the customer's product list.
- **`currency`**  <span style="font-size: 12px; font-weight: 500;">optional, default is GBP</span>
Currency code for the price. In [ISO 4217][] three-letter format.
- **`units_prices`**  <span style="font-size: 12px; font-weight: 500;">required</span>
List of units and their prices that the item can be ordered in.
- **`units_prices.unit`**  <span style="font-size: 12px; font-weight: 500;">required</span>
A unit that the item can be ordered in.
- **`units_prices.price_cents`**  <span style="font-size: 12px; font-weight: 500;">optional, default is 0</span>
The order price in cents for the item per unit.
For example, a currency of GBP with unit 5L and price 850 means a 5L item can be ordered for £8.50.
- **`units_prices.stock_count`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
The number of items in stock for the related unit.
- **`availability`**  <span style="font-size: 12px; font-weight: 500;">optional, default is "in_stock"</span>
Availability status of the item. Can be "in_stock", "out_of_stock", or "discontinued".
- **`description`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
Short description of the item.
- **`allergens`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
List of allergens for the item, if any.
- **`allergens.type`**  <span style="font-size: 12px; font-weight: 500;">required when allergens is given</span>
Type of allergy. For example "contains peanuts" or "may contain peanuts".
- **`allergens.symptoms`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
List of symptoms for the allergy.
- **`order_cutoff_times`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
Cutt-off times are the minimum amount of time before delivery when the item can still be ordered.
- **`order_cutoff_times.{mon,tue,wed,thu,fri,sat,sun}`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
Minimum amount of time, in hours, that an item needs to be ordered in advance of delivery for the given day.
- **`replacement_products`**   <span style="font-size: 12px; font-weight: 500;">optional</span>
List of product codes for alternative items when this item is not available.
- **`seasonality`**   <span style="font-size: 12px; font-weight: 500;">optional</span>
List of date ranges when the item is in-season.
- **`seasonality.start_date`**  <span style="font-size: 12px; font-weight: 500;">required when seasonality is given</span>
  The start date when the item is in season. In [ISO 8601][] calendar date format `YYYY-MM-DD`.
  - **`seasonality.end_date`**  <span style="font-size: 12px; font-weight: 500;">required when seasonality is given</span>
    The end date when the item is in season. In [ISO 8601][] calendar date format `YYYY-MM-DD`.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiReplaceCatalogRequest
 */
func (a *CatalogApiService) ReplaceCatalog(ctx _context.Context) ApiReplaceCatalogRequest {
	return ApiReplaceCatalogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return MainSuccessConfirmation
 */
func (a *CatalogApiService) ReplaceCatalogExecute(r ApiReplaceCatalogRequest) (MainSuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainSuccessConfirmation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogApiService.ReplaceCatalog")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/catalog/replace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCatalogV3Request struct {
	ctx _context.Context
	ApiService *CatalogApiService
	xREKKIAuthorizationType *string
	input *V3ReplaceCatalogInput
}

func (r ApiReplaceCatalogV3Request) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiReplaceCatalogV3Request {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiReplaceCatalogV3Request) Input(input V3ReplaceCatalogInput) ApiReplaceCatalogV3Request {
	r.input = &input
	return r
}

func (r ApiReplaceCatalogV3Request) Execute() (V3SuccessConfirmation, *_nethttp.Response, error) {
	return r.ApiService.ReplaceCatalogV3Execute(r)
}

/*
 * ReplaceCatalogV3 Drop all existing items from the catalog and upload new ones
 * ### Parameters

- **`id`**
REKKI's ID to uniquely identify the catalog item (for REKKI internal reference).
If `id` is specified the item will be update, if not it will attempt to insert it.
- **`product_code`**  <span style="font-size: 12px; font-weight: 500;">required</span>
Product code for the item that maps to the supplier's catalog.
Suppliers can modify the product code for future orders at https://supplier.rekki.com
- **`name`**  <span style="font-size: 12px; font-weight: 500;">required</span>
Item name as would be defined on the customer's product list.
- **`currency`**  <span style="font-size: 12px; font-weight: 500;">optional, default is GBP</span>
Currency code for the price. In [ISO 4217][] three-letter format.
- **`units_prices`**  <span style="font-size: 12px; font-weight: 500;">required</span>
List of units and their prices that the item can be ordered in.
- **`units_prices.unit`**  <span style="font-size: 12px; font-weight: 500;">required</span>
A unit that the item can be ordered in.
- **`units_prices.price_cents`**  <span style="font-size: 12px; font-weight: 500;">optional, default is 0</span>
The order price in cents for the item per unit.
For example, a currency of GBP with unit 5L and price 850 means a 5L item can be ordered for £8.50.
- **`units_prices.stock_count`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
The number of items in stock for the related unit.
- **`availability`**  <span style="font-size: 12px; font-weight: 500;">optional, default is "in_stock"</span>
Availability status of the item. Can be "in_stock", "out_of_stock", or "discontinued".
- **`description`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
Short description of the item.
- **`allergens`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
List of allergens for the item, if any.
- **`allergens.type`**  <span style="font-size: 12px; font-weight: 500;">required when allergens is given</span>
Type of allergy. For example "contains peanuts" or "may contain peanuts".
- **`allergens.symptoms`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
List of symptoms for the allergy.
- **`order_cutoff_times`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
Cutt-off times are the minimum amount of time before delivery when the item can still be ordered.
- **`order_cutoff_times.{mon,tue,wed,thu,fri,sat,sun}`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
Minimum amount of time, in hours, that an item needs to be ordered in advance of delivery for the given day.
- **`replacement_products`**   <span style="font-size: 12px; font-weight: 500;">optional</span>
List of product codes for alternative items when this item is not available.
- **`seasonality`**   <span style="font-size: 12px; font-weight: 500;">optional</span>
List of date ranges when the item is in-season.
- **`seasonality.start_date`**  <span style="font-size: 12px; font-weight: 500;">required when seasonality is given</span>
  The start date when the item is in season. In [ISO 8601][] calendar date format `YYYY-MM-DD`.
  - **`seasonality.end_date`**  <span style="font-size: 12px; font-weight: 500;">required when seasonality is given</span>
    The end date when the item is in season. In [ISO 8601][] calendar date format `YYYY-MM-DD`.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiReplaceCatalogV3Request
 */
func (a *CatalogApiService) ReplaceCatalogV3(ctx _context.Context) ApiReplaceCatalogV3Request {
	return ApiReplaceCatalogV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return V3SuccessConfirmation
 */
func (a *CatalogApiService) ReplaceCatalogV3Execute(r ApiReplaceCatalogV3Request) (V3SuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3SuccessConfirmation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogApiService.ReplaceCatalogV3")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v3/catalog/replace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3GenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCatalogItemRequest struct {
	ctx _context.Context
	ApiService *CatalogApiService
	xREKKIAuthorizationType *string
	input *MainAPISupplierCatalogItem
}

func (r ApiUpdateCatalogItemRequest) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiUpdateCatalogItemRequest {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiUpdateCatalogItemRequest) Input(input MainAPISupplierCatalogItem) ApiUpdateCatalogItemRequest {
	r.input = &input
	return r
}

func (r ApiUpdateCatalogItemRequest) Execute() (MainAPISupplierCatalogItem, *_nethttp.Response, error) {
	return r.ApiService.UpdateCatalogItemExecute(r)
}

/*
 * UpdateCatalogItem Creates or Updates an item on your catalog. If item with this product_code already exists, you can update this item. Item is looked up by product code
 * ### Parameters

- **`id`**
REKKI's ID to uniquely identify the catalog item (for REKKI internal reference).
If `id` is specified the item will be update, if not it will attempt to insert it.
- **`product_code`**  <span style="font-size: 12px; font-weight: 500;">required</span>
Product code for the item that maps to the supplier's catalog.
Suppliers can modify the product code for future orders at https://supplier.rekki.com
- **`name`**  <span style="font-size: 12px; font-weight: 500;">required</span>
Item name as would be defined on the customer's product list.
- **`currency`**  <span style="font-size: 12px; font-weight: 500;">optional, default is GBP</span>
Currency code for the price. In [ISO 4217][] three-letter format.
- **`units_prices`**  <span style="font-size: 12px; font-weight: 500;">required</span>
List of units and their prices that the item can be ordered in.
- **`units_prices.unit`**  <span style="font-size: 12px; font-weight: 500;">required</span>
A unit that the item can be ordered in.
- **`units_prices.price_cents`**  <span style="font-size: 12px; font-weight: 500;">optional, default is 0</span>
The order price in cents for the item per unit.
For example, a currency of GBP with unit 5L and price 850 means a 5L item can be ordered for £8.50.
- **`units_prices.stock_count`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
The number of items in stock for the related unit.
- **`availability`**  <span style="font-size: 12px; font-weight: 500;">optional, default is "in_stock"</span>
Availability status of the item. Can be "in_stock", "out_of_stock", or "discontinued".
- **`description`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
Short description of the item.
- **`allergens`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
List of allergens for the item, if any.
- **`allergens.type`**  <span style="font-size: 12px; font-weight: 500;">required when allergens is given</span>
Type of allergy. For example "contains peanuts" or "may contain peanuts".
- **`allergens.symptoms`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
List of symptoms for the allergy.
- **`order_cutoff_times`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
Cutt-off times are the minimum amount of time before delivery when the item can still be ordered.
- **`order_cutoff_times.{mon,tue,wed,thu,fri,sat,sun}`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
Minimum amount of time, in hours, that an item needs to be ordered in advance of delivery for the given day.
- **`replacement_products`**   <span style="font-size: 12px; font-weight: 500;">optional</span>
List of product codes for alternative items when this item is not available.
- **`seasonality`**   <span style="font-size: 12px; font-weight: 500;">optional</span>
List of date ranges when the item is in-season.
- **`seasonality.start_date`**  <span style="font-size: 12px; font-weight: 500;">required when seasonality is given</span>
  The start date when the item is in season. In [ISO 8601][] calendar date format `YYYY-MM-DD`.
  - **`seasonality.end_date`**  <span style="font-size: 12px; font-weight: 500;">required when seasonality is given</span>
    The end date when the item is in season. In [ISO 8601][] calendar date format `YYYY-MM-DD`.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateCatalogItemRequest
 */
func (a *CatalogApiService) UpdateCatalogItem(ctx _context.Context) ApiUpdateCatalogItemRequest {
	return ApiUpdateCatalogItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return MainAPISupplierCatalogItem
 */
func (a *CatalogApiService) UpdateCatalogItemExecute(r ApiUpdateCatalogItemRequest) (MainAPISupplierCatalogItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainAPISupplierCatalogItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogApiService.UpdateCatalogItem")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/catalog/items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCatalogItemAvailabilityRequest struct {
	ctx _context.Context
	ApiService *CatalogApiService
	xREKKIAuthorizationType *string
	input *MainSetStockStatusInput
}

func (r ApiUpdateCatalogItemAvailabilityRequest) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiUpdateCatalogItemAvailabilityRequest {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiUpdateCatalogItemAvailabilityRequest) Input(input MainSetStockStatusInput) ApiUpdateCatalogItemAvailabilityRequest {
	r.input = &input
	return r
}

func (r ApiUpdateCatalogItemAvailabilityRequest) Execute() (MainUpdateSuccess, *_nethttp.Response, error) {
	return r.ApiService.UpdateCatalogItemAvailabilityExecute(r)
}

/*
 * UpdateCatalogItemAvailability Update availability status for one of the items in the catalog
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateCatalogItemAvailabilityRequest
 */
func (a *CatalogApiService) UpdateCatalogItemAvailability(ctx _context.Context) ApiUpdateCatalogItemAvailabilityRequest {
	return ApiUpdateCatalogItemAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return MainUpdateSuccess
 */
func (a *CatalogApiService) UpdateCatalogItemAvailabilityExecute(r ApiUpdateCatalogItemAvailabilityRequest) (MainUpdateSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainUpdateSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogApiService.UpdateCatalogItemAvailability")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v2/catalog/items/availability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCatalogItemAvailabilityV3Request struct {
	ctx _context.Context
	ApiService *CatalogApiService
	xREKKIAuthorizationType *string
	input *V3SetStockStatusInput
}

func (r ApiUpdateCatalogItemAvailabilityV3Request) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiUpdateCatalogItemAvailabilityV3Request {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiUpdateCatalogItemAvailabilityV3Request) Input(input V3SetStockStatusInput) ApiUpdateCatalogItemAvailabilityV3Request {
	r.input = &input
	return r
}

func (r ApiUpdateCatalogItemAvailabilityV3Request) Execute() (V3UpdateSuccess, *_nethttp.Response, error) {
	return r.ApiService.UpdateCatalogItemAvailabilityV3Execute(r)
}

/*
 * UpdateCatalogItemAvailabilityV3 Update availability status for one of the items in the catalog
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateCatalogItemAvailabilityV3Request
 */
func (a *CatalogApiService) UpdateCatalogItemAvailabilityV3(ctx _context.Context) ApiUpdateCatalogItemAvailabilityV3Request {
	return ApiUpdateCatalogItemAvailabilityV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return V3UpdateSuccess
 */
func (a *CatalogApiService) UpdateCatalogItemAvailabilityV3Execute(r ApiUpdateCatalogItemAvailabilityV3Request) (V3UpdateSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3UpdateSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogApiService.UpdateCatalogItemAvailabilityV3")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v3/catalog/items/availability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3AvailabilityErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCatalogItemsV3Request struct {
	ctx _context.Context
	ApiService *CatalogApiService
	xREKKIAuthorizationType *string
	input *V3UpdateCatalogInput
}

func (r ApiUpdateCatalogItemsV3Request) XREKKIAuthorizationType(xREKKIAuthorizationType string) ApiUpdateCatalogItemsV3Request {
	r.xREKKIAuthorizationType = &xREKKIAuthorizationType
	return r
}
func (r ApiUpdateCatalogItemsV3Request) Input(input V3UpdateCatalogInput) ApiUpdateCatalogItemsV3Request {
	r.input = &input
	return r
}

func (r ApiUpdateCatalogItemsV3Request) Execute() (V3CatalogItems, *_nethttp.Response, error) {
	return r.ApiService.UpdateCatalogItemsV3Execute(r)
}

/*
 * UpdateCatalogItemsV3 Creates or Updates multiple items on your catalog. If item with this product_code already exists, you can update this item. Item is looked up by product code
 * ### Parameters

- **`id`**
REKKI's ID to uniquely identify the catalog item (for REKKI internal reference).
If `id` is specified the item will be update, if not it will attempt to insert it.
- **`product_code`**  <span style="font-size: 12px; font-weight: 500;">required</span>
Product code for the item that maps to the supplier's catalog.
Suppliers can modify the product code for future orders at https://supplier.rekki.com
- **`name`**  <span style="font-size: 12px; font-weight: 500;">required</span>
Item name as would be defined on the customer's product list.
- **`currency`**  <span style="font-size: 12px; font-weight: 500;">optional, default is GBP</span>
Currency code for the price. In [ISO 4217][] three-letter format.
- **`units_prices`**  <span style="font-size: 12px; font-weight: 500;">required</span>
List of units and their prices that the item can be ordered in.
- **`units_prices.unit`**  <span style="font-size: 12px; font-weight: 500;">required</span>
A unit that the item can be ordered in.
- **`units_prices.price_cents`**  <span style="font-size: 12px; font-weight: 500;">optional, default is 0</span>
The order price in cents for the item per unit.
For example, a currency of GBP with unit 5L and price 850 means a 5L item can be ordered for £8.50.
- **`units_prices.stock_count`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
The number of items in stock for the related unit.
- **`availability`**  <span style="font-size: 12px; font-weight: 500;">optional, default is "in_stock"</span>
Availability status of the item. Can be "in_stock", "out_of_stock", or "discontinued".
- **`description`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
Short description of the item.
- **`allergens`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
List of allergens for the item, if any.
- **`allergens.type`**  <span style="font-size: 12px; font-weight: 500;">required when allergens is given</span>
Type of allergy. For example "contains peanuts" or "may contain peanuts".
- **`allergens.symptoms`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
List of symptoms for the allergy.
- **`order_cutoff_times`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
Cutt-off times are the minimum amount of time before delivery when the item can still be ordered.
- **`order_cutoff_times.{mon,tue,wed,thu,fri,sat,sun}`**  <span style="font-size: 12px; font-weight: 500;">optional</span>
Minimum amount of time, in hours, that an item needs to be ordered in advance of delivery for the given day.
- **`replacement_products`**   <span style="font-size: 12px; font-weight: 500;">optional</span>
List of product codes for alternative items when this item is not available.
- **`seasonality`**   <span style="font-size: 12px; font-weight: 500;">optional</span>
List of date ranges when the item is in-season.
- **`seasonality.start_date`**  <span style="font-size: 12px; font-weight: 500;">required when seasonality is given</span>
  The start date when the item is in season. In [ISO 8601][] calendar date format `YYYY-MM-DD`.
  - **`seasonality.end_date`**  <span style="font-size: 12px; font-weight: 500;">required when seasonality is given</span>
    The end date when the item is in season. In [ISO 8601][] calendar date format `YYYY-MM-DD`.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateCatalogItemsV3Request
 */
func (a *CatalogApiService) UpdateCatalogItemsV3(ctx _context.Context) ApiUpdateCatalogItemsV3Request {
	return ApiUpdateCatalogItemsV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return V3CatalogItems
 */
func (a *CatalogApiService) UpdateCatalogItemsV3Execute(r ApiUpdateCatalogItemsV3Request) (V3CatalogItems, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3CatalogItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogApiService.UpdateCatalogItemsV3")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v3/catalog/items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xREKKIAuthorizationType == nil {
		return localVarReturnValue, nil, reportError("xREKKIAuthorizationType is required and must be specified")
	}
	if r.input == nil {
		return localVarReturnValue, nil, reportError("input is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(*r.xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = r.input
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3GenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
