/*
 * Rekki.com Supply API
 *
 * The base URL for all API endpoints is https://api.rekki.com  Api key value contains of word Bearer together with api key that you can get from integrations@rekki.com 
 *
 * API version: 
 * Contact: integrations@rekki.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// CatalogApiService CatalogApi service
type CatalogApiService service

/*
DeleteCatalogItem Delete an item from catalog
Delete an item from your catalog by its unique ID.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param id ID of the item to retrieve. Item IDs are discoverable when listing items.
@return MainSuccessConfirmation
*/
func (a *CatalogApiService) DeleteCatalogItem(ctx _context.Context, xREKKIAuthorizationType string, id string) (MainSuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainSuccessConfirmation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/catalog/items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
DeleteCatalogItemsV3 Delete items from catalog
Delete items from the catalog by its unique IDs.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return V3SuccessConfirmation
*/
func (a *CatalogApiService) DeleteCatalogItemsV3(ctx _context.Context, xREKKIAuthorizationType string, input V3DeleteCatalogItemsInput) (V3SuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3SuccessConfirmation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/catalog/items/delete"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetCatalogItem Lists all orders placed for the supplier that were placed through REKKI.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param id ID of the item to retrieve. Item IDs are discoverable when listing items.
@return MainApiSupplierCatalogItem
*/
func (a *CatalogApiService) GetCatalogItem(ctx _context.Context, xREKKIAuthorizationType string, id string) (MainApiSupplierCatalogItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainApiSupplierCatalogItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/catalog/items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetCatalogItemV3 Fetch a specific catalog item by its Id.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param id ID of the item to retrieve. Item IDs are discoverable when listing items.
@return V3ApiSupplierCatalogItem
*/
func (a *CatalogApiService) GetCatalogItemV3(ctx _context.Context, xREKKIAuthorizationType string, id string) (V3ApiSupplierCatalogItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3ApiSupplierCatalogItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/catalog/items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V3GenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetCatalogItems Get catalog items for authenticated supplier
Lists all your catalog items. Sorted by creation date, with the oldest appearing first. No input parameters. Options for pagination and sorting direction may be introduced later. Response is a JSON object with a data property that contains catalog items of the authenticated supplier.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
@return MainCatalogItems
*/
func (a *CatalogApiService) GetCatalogItems(ctx _context.Context, xREKKIAuthorizationType string) (MainCatalogItems, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainCatalogItems
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/catalog/items"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetCatalogItemsV3 Get catalog items for authenticated supplier
Lists all your catalog items. Sorted by creation date, with the oldest appearing first. No input parameters. Options for pagination and sorting direction may be introduced later. Response is a JSON object with a data property that contains catalog items of the authenticated supplier.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
@return V3CatalogItems
*/
func (a *CatalogApiService) GetCatalogItemsV3(ctx _context.Context, xREKKIAuthorizationType string) (V3CatalogItems, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3CatalogItems
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/catalog/items"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ReplaceCatalog Drop all existing items from the catalog and upload new ones
### Parameters  - **&#x60;id&#x60;** REKKI&#39;s ID to uniquely identify the catalog item (for REKKI internal reference). If &#x60;id&#x60; is specified the item will be update, if not it will attempt to insert it. - **&#x60;product_code&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Product code for the item that maps to the supplier&#39;s catalog. Suppliers can modify the product code for future orders at https://supplier.rekki.com - **&#x60;name&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Item name as would be defined on the customer&#39;s product list. - **&#x60;currency&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is GBP&lt;/span&gt; Currency code for the price. In [ISO 4217][] three-letter format. - **&#x60;units_prices&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; List of units and their prices that the item can be ordered in. - **&#x60;units_prices.unit&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; A unit that the item can be ordered in. - **&#x60;units_prices.price_cents&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is 0&lt;/span&gt; The order price in cents for the item per unit. For example, a currency of GBP with unit 5L and price 850 means a 5L item can be ordered for £8.50. - **&#x60;units_prices.stock_count&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; The number of items in stock for the related unit. - **&#x60;availability&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is \&quot;in_stock\&quot;&lt;/span&gt; Availability status of the item. Can be \&quot;in_stock\&quot;, \&quot;out_of_stock\&quot;, or \&quot;discontinued\&quot;. - **&#x60;description&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Short description of the item. - **&#x60;allergens&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of allergens for the item, if any. - **&#x60;allergens.type&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when allergens is given&lt;/span&gt; Type of allergy. For example \&quot;contains peanuts\&quot; or \&quot;may contain peanuts\&quot;. - **&#x60;allergens.symptoms&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of symptoms for the allergy. - **&#x60;order_cutoff_times&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Cutt-off times are the minimum amount of time before delivery when the item can still be ordered. - **&#x60;order_cutoff_times.{mon,tue,wed,thu,fri,sat,sun}&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Minimum amount of time, in hours, that an item needs to be ordered in advance of delivery for the given day. - **&#x60;replacement_products&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of product codes for alternative items when this item is not available. - **&#x60;seasonality&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of date ranges when the item is in-season. - **&#x60;seasonality.start_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;   The start date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;.   - **&#x60;seasonality.end_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;     The end date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return MainSuccessConfirmation
*/
func (a *CatalogApiService) ReplaceCatalog(ctx _context.Context, xREKKIAuthorizationType string, input MainReplaceCatalogInput) (MainSuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainSuccessConfirmation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/catalog/replace"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ReplaceCatalogV3 Drop all existing items from the catalog and upload new ones
### Parameters  - **&#x60;id&#x60;** REKKI&#39;s ID to uniquely identify the catalog item (for REKKI internal reference). If &#x60;id&#x60; is specified the item will be update, if not it will attempt to insert it. - **&#x60;product_code&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Product code for the item that maps to the supplier&#39;s catalog. Suppliers can modify the product code for future orders at https://supplier.rekki.com - **&#x60;name&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Item name as would be defined on the customer&#39;s product list. - **&#x60;currency&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is GBP&lt;/span&gt; Currency code for the price. In [ISO 4217][] three-letter format. - **&#x60;units_prices&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; List of units and their prices that the item can be ordered in. - **&#x60;units_prices.unit&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; A unit that the item can be ordered in. - **&#x60;units_prices.price_cents&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is 0&lt;/span&gt; The order price in cents for the item per unit. For example, a currency of GBP with unit 5L and price 850 means a 5L item can be ordered for £8.50. - **&#x60;units_prices.stock_count&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; The number of items in stock for the related unit. - **&#x60;availability&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is \&quot;in_stock\&quot;&lt;/span&gt; Availability status of the item. Can be \&quot;in_stock\&quot;, \&quot;out_of_stock\&quot;, or \&quot;discontinued\&quot;. - **&#x60;description&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Short description of the item. - **&#x60;allergens&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of allergens for the item, if any. - **&#x60;allergens.type&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when allergens is given&lt;/span&gt; Type of allergy. For example \&quot;contains peanuts\&quot; or \&quot;may contain peanuts\&quot;. - **&#x60;allergens.symptoms&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of symptoms for the allergy. - **&#x60;order_cutoff_times&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Cutt-off times are the minimum amount of time before delivery when the item can still be ordered. - **&#x60;order_cutoff_times.{mon,tue,wed,thu,fri,sat,sun}&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Minimum amount of time, in hours, that an item needs to be ordered in advance of delivery for the given day. - **&#x60;replacement_products&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of product codes for alternative items when this item is not available. - **&#x60;seasonality&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of date ranges when the item is in-season. - **&#x60;seasonality.start_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;   The start date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;.   - **&#x60;seasonality.end_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;     The end date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return V3SuccessConfirmation
*/
func (a *CatalogApiService) ReplaceCatalogV3(ctx _context.Context, xREKKIAuthorizationType string, input V3ReplaceCatalogInput) (V3SuccessConfirmation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3SuccessConfirmation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/catalog/replace"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3GenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
UpdateCatalogItem Creates or Updates an item on your catalog. If item with this product_code already exists, you can update this item. Item is looked up by product code
### Parameters  - **&#x60;id&#x60;** REKKI&#39;s ID to uniquely identify the catalog item (for REKKI internal reference). If &#x60;id&#x60; is specified the item will be update, if not it will attempt to insert it. - **&#x60;product_code&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Product code for the item that maps to the supplier&#39;s catalog. Suppliers can modify the product code for future orders at https://supplier.rekki.com - **&#x60;name&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Item name as would be defined on the customer&#39;s product list. - **&#x60;currency&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is GBP&lt;/span&gt; Currency code for the price. In [ISO 4217][] three-letter format. - **&#x60;units_prices&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; List of units and their prices that the item can be ordered in. - **&#x60;units_prices.unit&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; A unit that the item can be ordered in. - **&#x60;units_prices.price_cents&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is 0&lt;/span&gt; The order price in cents for the item per unit. For example, a currency of GBP with unit 5L and price 850 means a 5L item can be ordered for £8.50. - **&#x60;units_prices.stock_count&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; The number of items in stock for the related unit. - **&#x60;availability&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is \&quot;in_stock\&quot;&lt;/span&gt; Availability status of the item. Can be \&quot;in_stock\&quot;, \&quot;out_of_stock\&quot;, or \&quot;discontinued\&quot;. - **&#x60;description&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Short description of the item. - **&#x60;allergens&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of allergens for the item, if any. - **&#x60;allergens.type&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when allergens is given&lt;/span&gt; Type of allergy. For example \&quot;contains peanuts\&quot; or \&quot;may contain peanuts\&quot;. - **&#x60;allergens.symptoms&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of symptoms for the allergy. - **&#x60;order_cutoff_times&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Cutt-off times are the minimum amount of time before delivery when the item can still be ordered. - **&#x60;order_cutoff_times.{mon,tue,wed,thu,fri,sat,sun}&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Minimum amount of time, in hours, that an item needs to be ordered in advance of delivery for the given day. - **&#x60;replacement_products&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of product codes for alternative items when this item is not available. - **&#x60;seasonality&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of date ranges when the item is in-season. - **&#x60;seasonality.start_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;   The start date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;.   - **&#x60;seasonality.end_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;     The end date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return MainApiSupplierCatalogItem
*/
func (a *CatalogApiService) UpdateCatalogItem(ctx _context.Context, xREKKIAuthorizationType string, input MainApiSupplierCatalogItem) (MainApiSupplierCatalogItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainApiSupplierCatalogItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v1/catalog/items"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
UpdateCatalogItemAvailability Update availability status for one of the items in the catalog
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return MainUpdateSuccess
*/
func (a *CatalogApiService) UpdateCatalogItemAvailability(ctx _context.Context, xREKKIAuthorizationType string, input MainSetStockStatusInput) (MainUpdateSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MainUpdateSuccess
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v2/catalog/items/availability"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MainGenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
UpdateCatalogItemAvailabilityV3 Update availability status for one of the items in the catalog
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return V3UpdateSuccess
*/
func (a *CatalogApiService) UpdateCatalogItemAvailabilityV3(ctx _context.Context, xREKKIAuthorizationType string, input V3SetStockStatusInput) (V3UpdateSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3UpdateSuccess
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/catalog/items/availability"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3AvailabilityErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
UpdateCatalogItemsV3 Creates or Updates multiple items on your catalog. If item with this product_code already exists, you can update this item. Item is looked up by product code
### Parameters  - **&#x60;id&#x60;** REKKI&#39;s ID to uniquely identify the catalog item (for REKKI internal reference). If &#x60;id&#x60; is specified the item will be update, if not it will attempt to insert it. - **&#x60;product_code&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Product code for the item that maps to the supplier&#39;s catalog. Suppliers can modify the product code for future orders at https://supplier.rekki.com - **&#x60;name&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; Item name as would be defined on the customer&#39;s product list. - **&#x60;currency&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is GBP&lt;/span&gt; Currency code for the price. In [ISO 4217][] three-letter format. - **&#x60;units_prices&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; List of units and their prices that the item can be ordered in. - **&#x60;units_prices.unit&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required&lt;/span&gt; A unit that the item can be ordered in. - **&#x60;units_prices.price_cents&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is 0&lt;/span&gt; The order price in cents for the item per unit. For example, a currency of GBP with unit 5L and price 850 means a 5L item can be ordered for £8.50. - **&#x60;units_prices.stock_count&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; The number of items in stock for the related unit. - **&#x60;availability&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional, default is \&quot;in_stock\&quot;&lt;/span&gt; Availability status of the item. Can be \&quot;in_stock\&quot;, \&quot;out_of_stock\&quot;, or \&quot;discontinued\&quot;. - **&#x60;description&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Short description of the item. - **&#x60;allergens&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of allergens for the item, if any. - **&#x60;allergens.type&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when allergens is given&lt;/span&gt; Type of allergy. For example \&quot;contains peanuts\&quot; or \&quot;may contain peanuts\&quot;. - **&#x60;allergens.symptoms&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of symptoms for the allergy. - **&#x60;order_cutoff_times&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Cutt-off times are the minimum amount of time before delivery when the item can still be ordered. - **&#x60;order_cutoff_times.{mon,tue,wed,thu,fri,sat,sun}&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; Minimum amount of time, in hours, that an item needs to be ordered in advance of delivery for the given day. - **&#x60;replacement_products&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of product codes for alternative items when this item is not available. - **&#x60;seasonality&#x60;**   &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;optional&lt;/span&gt; List of date ranges when the item is in-season. - **&#x60;seasonality.start_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;   The start date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;.   - **&#x60;seasonality.end_date&#x60;**  &lt;span style&#x3D;\&quot;font-size: 12px; font-weight: 500;\&quot;&gt;required when seasonality is given&lt;/span&gt;     The end date when the item is in season. In [ISO 8601][] calendar date format &#x60;YYYY-MM-DD&#x60;. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xREKKIAuthorizationType Required header
 * @param input Payload
@return V3CatalogItems
*/
func (a *CatalogApiService) UpdateCatalogItemsV3(ctx _context.Context, xREKKIAuthorizationType string, input V3UpdateCatalogInput) (V3CatalogItems, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V3CatalogItems
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/integration/v3/catalog/items"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-REKKI-Authorization-Type"] = parameterToString(xREKKIAuthorizationType, "")
	// body params
	localVarPostBody = &input
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V3GenericErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
